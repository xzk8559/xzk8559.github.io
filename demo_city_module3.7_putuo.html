<!DOCTYPE html>

<html lang="en">
<head>
    <title> PuTuo_Demo </title>
    <meta charset="utf-8">
    <link type="text/css" rel="stylesheet" href="./main.css">
</head>
<body>

<div id="WebGL-output"></div>
<div id="Stats-output"></div>

<script type="module">

    import { GUI } from "./three.js_115/examples/jsm/libs/dat.gui.module.js";
    import { OrbitControls } from './three.js_115/examples/jsm/controls/OrbitControls.js';
    import * as THREE from "./three.js_115/build/three.module.js";
    import { BLOCKBuilding } from "./buildinggenerater2_putuo.js";
    import { BLOCKBuilding_merge } from "./buildinggenerater2_merge.js";
    import { BLOCKBuilding_wireframe } from "./buildingedges.js";
    import { quadTree } from "./Quadtree_putuo.js";
    import { getRenderList } from "./getRenderList_v2.js";
    import Stats from "./three.js_115/examples/jsm/libs/stats.module.js";

    let map, demo, node;
    let stats, orbitControls, gui;
    let renderer, scene, camera, raycaster;
    let plane, light, building, obj, floor, dispNum, building_merge, wf_merge;
    let mouse = new THREE.Vector2(), INTERSECTED;
    let treeIteration = 6; // for n = 100,000, iteration > 6 recommended

    let state = {
        animated : false,
        extruded_model : true,
        wireframe : true,
        extruded_model_num : 2000,
        rayCaster_enabled : false,
        color_animated : false,
        displacement_animated : false,
        Amplitude : 1.0,
        Velocity : 1.0,
        Sight_Distance : 300,
        Lod1_visible : false,
        Reset : reset_camera,
        Reset_animation : reset_animation
    };

    function _time_controller(){

        this.last_time = 0;
        this.last_step = 0;
        this.current_time = 0;
        this.current_step = 0;

        this.update = function(){
            if (this.last_time === 0){this.last_time = new Date().getTime()}
            this.current_time = new Date().getTime();
            let time_increment = ( this.current_time - this.last_time ) / 1000;
            this.current_step = time_increment * sample_rate * state.Velocity + this.last_step;
            this.last_time = this.current_time;
            this.last_step = this.current_step;
        }
    }

    let times = new _time_controller();
    let sample_rate = 100,
        displace = 0,
        interpolation = 0;

    init();
    animate();

    function init() {

        initData();
        initStats();
        initRender();
        initScene();
        initCamera();
        initPlane();
        initLight();
        initModel();
        initControls();
        initGui();

        document.getElementById("WebGL-output").appendChild(renderer.domElement);
        document.getElementById("WebGL-output").addEventListener("dblclick", setBuildingData);
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

        function initData(){

            map = jsonLoader('Pu_Tuo_visualization.json', './');
            demo = [];
            for (let i = 0; i < 10; i++) {
                let filename = "DISP" + i.toString() + ".json";
                demo[i] = jsonLoader(filename, './reaction/');
            }

            function jsonLoader( filename, path ) {
                let url = path + filename;
                let jsonRequest = new XMLHttpRequest();
                jsonRequest.open( "GET", url, false );
                jsonRequest.send( null );
                return JSON.parse( jsonRequest.response )
            }

        }
        function initStats() {

            stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

        }
        function initRender(){
            renderer = new THREE.WebGLRenderer({antialias: true, precision: 'lowp'});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false;
        }
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color( '#474747' );
            scene.fog = new THREE.FogExp2( '#8d8d8d', 0.0006 );
        }
        function initCamera() {
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1200);
            camera.position.set( 20, 60, 20);
            camera.layers.enable( 0 ); // enabled by default
            camera.layers.enable( 1 );
            camera.layers.enable( 2 );

            raycaster = new THREE.Raycaster();
            raycaster.layers.set( 1 );
        }
        function initPlane() {
            let planeGeometry = new THREE.PlaneGeometry(1200, 1000, 1, 1);
            let planeMaterial = new THREE.MeshLambertMaterial({color: '#151515'});
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -0.5 * Math.PI;
            plane.position.x = 600;
            plane.position.y = 0;
            plane.position.z = 500;
            plane.layers.set( 0 );
            scene.add(plane);
        }
        function initLight() {
            light = new THREE.AmbientLight('#ffffff', 1.5);
            scene.add( light );
        }
        function initModel(){

            floor = [];
            building = [];
            obj = [];
            dispNum = [];

            scene.add(  new THREE.AxesHelper(10) );

            /**
             * @param {Object} map.buildings - Metadata.
             * @param {number} map.buildings.number
             * @param {Array} map.buildings.bounds
             */
            for (let ib = 0; ib < map.buildings.number; ib++) {

                dispNum[ib] = Math.floor(Math.random()*10);

                let floor_height = 3.0
                floor[ib] = Math.floor( map.buildings.height[ib] / floor_height );

                building[ib] = BLOCKBuilding( map, ib, floor_height, floor[ib] );

                building[ib].userData = {
                    bid: ib,
                    height: map.buildings.height[ib],
                    floor: Math.floor(map.buildings.height[ib] / 3.0)
                };

                scene.add(building[ib]);

                building[ib].layers.set( 1 );
                building[ib].frustumCulled = false;

                building[ib].onAfterRender = function () {
                    scene.remove(building[ib]);

                    if (state.color_animated){
                        for (let i = 0; i < floor[ib]+1; i++) {
                            let tmp = (i / floor[ib] - 1) * 0.03;
                            let pN = map.buildings.bounds[ib].length;
                            for (let n = 0; n < pN; n++) {
                                building[ib].geometry.attributes.color.array[(i * pN + n) * 3] = 0.18 + tmp;
                                building[ib].geometry.attributes.color.array[(i * pN + n) * 3 + 1] = 0.18 + tmp;
                                building[ib].geometry.attributes.color.array[(i * pN + n) * 3 + 2] = 0.20 + tmp;
                            }
                        }
                        building[ib].geometry.attributes.color.needsUpdate = true;
                    }
                };

            }

            building_merge = BLOCKBuilding_merge( map, map.buildings.height );
            wf_merge = BLOCKBuilding_wireframe( building_merge );

            scene.add(building_merge);
            scene.add(wf_merge);

            building_merge.layers.set( 2 );
            wf_merge.layers.set( 2 );
            building_merge.frustumCulled = false;
            wf_merge.layers.frustumCulled = false;

            building_merge.onAfterRender = function () {
                scene.remove(building_merge);
            }
            wf_merge.onAfterRender = function () {
                scene.remove(wf_merge);
            }

            node = quadTree(map, building, treeIteration);

        }
        function initControls() {

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.maxPolarAngle = 0.65 * Math.PI / 2;
            orbitControls.minPolarAngle = 0.1 * Math.PI / 2;
            orbitControls.target.set( 0, 0, 0 );

            // 如果使用animate方法时，将此函数删除
            //orbitControls.addEventListener( 'change', render );

            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.25;

            orbitControls.enableZoom = true;
            //是否自动旋转
            //orbitControls.autoRotate = false;
            //orbitControls.autoRotateSpeed = 0.5;
            //设置相机向外移动的距离
            orbitControls.maxDistance = 600;
            orbitControls.minDistance = 50;

            orbitControls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };

            orbitControls.update();
            orbitControls.saveState ();

        }
        function initGui() {

            gui = new GUI( { width: 300 } );

            let folder = gui.addFolder( "General Options" );

            folder.add( state, "animated" );
            folder.__controllers[ 0 ].name( "Animate" );

            folder.add( state, "extruded_model" );
            folder.__controllers[ 1 ].name( "ExtrudedModel" );

            folder.add( state, "wireframe" );
            folder.__controllers[ 2 ].name( "Wireframe" );

            folder.add( state, "rayCaster_enabled" );
            folder.__controllers[ 3 ].name( "Selectable" );

            folder.open();

            let folder2 = gui.addFolder( "Animation Options" );

            folder2.add( state, "color_animated" );
            folder2.__controllers[ 0 ].name( "Color Animate" );

            folder2.add( state, "displacement_animated" );
            folder2.__controllers[ 1 ].name( "Displacement Animate" );

            folder2.add( state, 'Amplitude', 0, 2 );
            folder2.add( state, 'Velocity', 0.1, 5 );
            folder2.add( state, 'Reset_animation' );

            folder2.open();

            let folder3 = gui.addFolder( "Performance Options" );

            folder3.add( state, "extruded_model_num", 0, map.buildings.number ).step(1.0);
            folder3.__controllers[ 0 ].name( `ExtrudedModel Number (<${map.buildings.number})` );

            folder3.add(state, 'Sight_Distance', 100, 1000).step(10);

            folder3.open();

        }
        function onWindowResize() {

            let width = window.innerWidth;
            let height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize( width, height );

        }
        function onDocumentMouseMove( event ) {

            event.preventDefault();

            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        }

    }
    function animate() {

        stats.update();
        orbitControls.update();
        // console.log(new Date().getTime())

        requestAnimationFrame( animate );
        render();

        function render() {

            // update parent page
            parent.vm.camera_x = camera.position.x.toFixed(1);
            parent.vm.camera_y = camera.position.z.toFixed(1);
            if (parent.cameraControls.isReset === 1){
                reset_camera();
                parent.cameraControls.isReset = 0;
            }

            let fru = computeFrustumFromCamera(camera);
            let renderList = getRenderList( fru, node, treeIteration );
            let renderNum = Math.min(state.extruded_model_num, renderList.length);

            if ( state.extruded_model ){
                if ( state.animated ){

                    times.update();
                    let time_step_int = Math.ceil(times.current_step);

                    for (let i = 0; i < renderNum; i++){

                        let ib = renderList[i];
                        let pDist = Math.pow(building[ib].geometry.attributes.position.array[0] - camera.position.x, 2) + Math.pow(building[ib].geometry.attributes.position.array[2] - camera.position.z, 2);

                        if ( pDist < Math.pow( state.Sight_Distance / 2, 2 ) ){
                            scene.add(building[ib]);

                            if (time_step_int < demo[dispNum[ib]].disp[0].length){
                                let pN = map.buildings.bounds[ib].length;

                                building[ib].geometry.attributes.position.needsUpdate = true;
                                building[ib].geometry.attributes.color.needsUpdate = true;

                                for (let i = 0; i < floor[ib]+1; i++) {
                                    let occlusion = (floor[ib] - i) / floor[ib] * 0.2;

                                    if (state.displacement_animated){
                                        displace = (demo[dispNum[ib]].disp[Math.min(i,18)+1][time_step_int] - demo[dispNum[ib]].disp[0][time_step_int])/1000;
                                        for (let n = 0; n < pN; n++){
                                            building[ib].geometry.attributes.position.array[(i * pN + n) * 3] = map.buildings.bounds[ib][n][0] + displace * state.Amplitude;
                                        }
                                    }
                                    if (state.color_animated){
                                        interpolation = Math.abs(demo[dispNum[ib]].disp[Math.min(i,18)+1][time_step_int] - demo[dispNum[ib]].disp[Math.min(i,18)][time_step_int])/30;
                                        for (let n = 0; n < pN; n++){
                                            building[ib].geometry.attributes.color.array[(i * pN + n) * 3] = 0.1 + interpolation - occlusion;
                                            building[ib].geometry.attributes.color.array[(i * pN + n) * 3 + 1] = 0.5 - occlusion;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else {

                    scene.add(building_merge);
                    for (let i = 0; i < renderNum; i++){

                        let ib = renderList[i];
                        let pDist = Math.pow(building[ib].geometry.attributes.position.array[0] - camera.position.x, 2) + Math.pow(building[ib].geometry.attributes.position.array[2] - camera.position.z, 2);

                        if ( pDist < Math.pow( state.Sight_Distance / 2, 2 ) ){
                            scene.add(building[ib]);
                        }
                    }
                }
            }
            if ( state.wireframe ){
                scene.add(wf_merge);
            }

            if ( state.rayCaster_enabled ){

                raycaster.setFromCamera( mouse, camera );

                let intersects = raycaster.intersectObjects( scene.children );

                if ( intersects.length > 0 ) {

                    if ( (INTERSECTED !== intersects[ 0 ].object) && (intersects[ 0 ].object.type !== 'LineSegments') ) {

                        // 还原hex
                        if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                        INTERSECTED.material.emissive.setHex( 0xffb346 );

                    }
                }
                else {
                    if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                    INTERSECTED = null;
                }

            }

            // console.log(renderer.info);
            renderer.render( scene, camera );
        }

    }

    function reset_camera () {

        let direction = new THREE.Vector3();
        camera.getWorldDirection(direction);

        camera.position.set(parent.vm.slider_x, 60, parent.vm.slider_y);
        camera.getWorldPosition(orbitControls.target);
        orbitControls.target.addScaledVector(direction, 50);
        //orbitControls.reset ();
        orbitControls.update();
        //console.log(orbitControls.position0);
        //console.log(camera);

    }
    function reset_animation () {
        times.last_step = 0;
    }
    function computeFrustumFromCamera(camera) {
        let frustum = new THREE.Frustum();
        frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
        return frustum;
    }
    async function setBuildingData() {
        if (INTERSECTED) {
            let geo = INTERSECTED.geometry;
            let file = "./request/bid_" + INTERSECTED.userData.bid.toString() + ".json";
            parent.loadTableData(file);
            parent.table_attr.bid.value = INTERSECTED.userData.bid;
            parent.table_attr.height.value = INTERSECTED.userData.height;
            parent.table_attr.floor.value = INTERSECTED.userData.floor;
            parent.table_attr.coordinate.value = "(" + geo.boundingSphere.center.x.toFixed(1).toString() + ", " + geo.boundingSphere.center.z.toFixed(1).toString() + ")";
            parent.table_attr.boundSp.value = geo.boundingSphere.radius.toFixed(2);
            parent.table_attr.triangles.value = geo.attributes.position.count;
        }
    }

</script>
</body>
</html>